/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WikidataImporterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/wikidata.ts
var import_obsidian = require("obsidian");
function isString(type) {
  if (!type)
    return false;
  return type === "http://www.w3.org/2001/XMLSchema#string" || type === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";
}
function isInteger(type) {
  if (!type)
    return false;
  return type === "http://www.w3.org/2001/XMLSchema#integer";
}
function isDecimal(type) {
  if (!type)
    return false;
  return type === "http://www.w3.org/2001/XMLSchema#decimal";
}
function isDate(type) {
  if (!type)
    return false;
  return type === "http://www.w3.org/2001/XMLSchema#dateTime";
}
var Entity = class {
  constructor(id, label, description) {
    this.id = id;
    this.label = label;
    this.description = description;
  }
  static fromJson(json) {
    return new Entity(json.id, json.label, json.description);
  }
  static fromId(id) {
    return new Entity(id);
  }
  static async search(query) {
    if (!query || query.length === 0)
      return [];
    const url = "https://www.wikidata.org/w/api.php?action=wbsearchentities&format=json&language=en&type=item&limit=10&search=" + encodeURIComponent(query);
    const response = await (0, import_obsidian.requestUrl)(url);
    const json = response.json;
    return json.search.map(Entity.fromJson);
  }
  static replaceCharacters(str, searchString, replaceString) {
    let result = str;
    for (let i = 0; i < searchString.length; i++) {
      const searchChar = searchString[i];
      const replaceChar = replaceString[Math.min(i, replaceString.length - 1)];
      result = result.replace(
        new RegExp("\\" + searchChar, "g"),
        replaceChar
      );
    }
    return result;
  }
  static buildLink(link, label, id) {
    label = Entity.replaceCharacters(label, '*/:#?<>"', "_");
    link = link.replace(/\$\{label\}/g, label).replace(/\$\{id\}/g, id);
    return link;
  }
  // TODO: incorporate https://query.wikidata.org/#SELECT%20%3FwdLabel%20%3Fps_Label%20%3FwdpqLabel%20%3Fpq_Label%20%7B%0A%20%20VALUES%20%28%3Fcompany%29%20%7B%28wd%3AQ5284%29%7D%0A%20%20%0A%20%20%3Fcompany%20%3Fp%20%3Fstatement%20.%0A%20%20%3Fstatement%20%3Fps%20%3Fps_%20.%0A%20%20%0A%20%20%3Fwd%20wikibase%3Aclaim%20%3Fp.%0A%20%20%3Fwd%20wikibase%3AstatementProperty%20%3Fps.%0A%20%20%0A%20%20OPTIONAL%20%7B%0A%20%20%3Fstatement%20%3Fpq%20%3Fpq_%20.%0A%20%20%3Fwdpq%20wikibase%3Aqualifier%20%3Fpq%20.%0A%20%20%7D%0A%20%20%0A%20%20SERVICE%20wikibase%3Alabel%20%7B%20bd%3AserviceParam%20wikibase%3Alanguage%20%22en%22%20%7D%0A%7D%20ORDER%20BY%20%3Fwd%20%3Fstatement%20%3Fps_
  async getProperties(opts) {
    let query = `
			SELECT ?propertyLabel ?value ?valueLabel ?valueType ?normalizedValue ?description WHERE {
				wd:${this.id} ?propUrl ?value .
				?property wikibase:directClaim ?propUrl .
				OPTIONAL { wd:${this.id} schema:description ?description . FILTER (LANG(?description) = "en") }
				OPTIONAL {
					?statement psn:P31 ?normalizedValue .
					?normalizedValue wikibase:quantityUnit ?unit .
				}
				BIND(DATATYPE(?value) AS ?valueType) .
		`;
    if (opts.ignorePropertiesWithTimeRanges) {
      query += `
				MINUS { ?value p:P580 ?startDateStatement. }
				MINUS { ?value p:P582 ?endDateStatement. }
				MINUS { ?value p:P585 ?pointInTimeStatement. }
			`;
    }
    query += `
				SERVICE wikibase:label {
					bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en" .
				}
			}
		`;
    const url = "https://query.wikidata.org/sparql?query=" + encodeURIComponent(query) + "&format=json";
    const response = await (0, import_obsidian.requestUrl)(url);
    const json = response.json;
    const results = json.results.bindings;
    const ret = {};
    results.forEach((r) => {
      const key = r.propertyLabel.value;
      const value = r.value.value;
      const normalizedValue = r.normalizedValue ? r.normalizedValue.value : null;
      const type = r.valueType ? r.valueType.value : null;
      const valueLabel = r.valueLabel ? r.valueLabel.value : null;
      if (opts.ignoreCategories && valueLabel && valueLabel.startsWith("Category:")) {
        return;
      }
      if (opts.ignoreWikipediaPages && valueLabel && valueLabel.startsWith("Wikipedia:")) {
        return;
      }
      if (opts.ignoreIDs && valueLabel && key.match(/\bID\b/)) {
        return;
      }
      let toAdd = valueLabel;
      if (normalizedValue) {
        toAdd = normalizedValue;
      } else if (isDate(type)) {
        toAdd = value;
      } else if (isDecimal(type)) {
        toAdd = parseFloat(value);
      } else if (isInteger(type)) {
        toAdd = parseInt(value);
      } else if (isString(type)) {
        toAdd = value;
      } else if (value.match(/Q\d+$/) && valueLabel) {
        let id = value.match(/\d+$/);
        var label = Entity.buildLink(
          opts.internalLinkPrefix,
          valueLabel,
          id[0]
        );
        toAdd = `[[${label}]]`;
      }
      if (toAdd === null) {
        return;
      }
      if (ret[key]) {
        ret[key].push(toAdd);
      } else {
        ret[key] = [toAdd];
      }
    });
    return ret;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  entityIdKey: "wikidata entity id",
  internalLinkPrefix: "db/${label}",
  ignoreCategories: true,
  ignoreWikipediaPages: true,
  ignoreIDs: true,
  ignorePropertiesWithTimeRanges: true,
  overwriteExistingProperties: false,
  blockedProperties: [],
  allowedProperties: []
};
async function syncEntityToFile(plugin, entity, file) {
  var _a, _b, _c;
  let frontmatter = (_a = plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
  if (!frontmatter) {
    frontmatter = {};
  }
  let properties = await entity.getProperties({
    ignoreCategories: plugin.settings.ignoreCategories,
    ignoreWikipediaPages: plugin.settings.ignoreWikipediaPages,
    ignoreIDs: plugin.settings.ignoreIDs,
    ignorePropertiesWithTimeRanges: plugin.settings.ignorePropertiesWithTimeRanges,
    internalLinkPrefix: plugin.settings.internalLinkPrefix
  });
  const filteredProperties = [];
  for (const [key, value] of Object.entries(properties)) {
    if (
      // If the "allowed properties" is defined, only import properties that are defined in the setting
      // If the "blocked properties" is defined, do not import properties that are defined in the setting
      ((_b = plugin.settings.allowedProperties) == null ? void 0 : _b.length) && !plugin.settings.allowedProperties.includes(key) || ((_c = plugin.settings.blockedProperties) == null ? void 0 : _c.length) && plugin.settings.blockedProperties.includes(key)
    ) {
      console.log(`Wikidata: skipping property ${key}`);
      continue;
    } else {
      filteredProperties.push(key);
    }
    frontmatter[key] = value.length === 1 ? value[0] : value;
  }
  await plugin.app.fileManager.processFrontMatter(file, (frontmatter2) => {
    for (const [key, value] of Object.entries(properties)) {
      if (filteredProperties.includes(key)) {
        if (plugin.settings.overwriteExistingProperties) {
          frontmatter2[key] = value.length === 1 ? value[0] : value;
        } else if (!frontmatter2[key]) {
          frontmatter2[key] = value.length === 1 ? value[0] : value;
        }
      }
    }
    frontmatter2[plugin.settings.entityIdKey] = entity.id;
  });
}
var WikidataEntitySuggestModal = class extends import_obsidian2.SuggestModal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.setPlaceholder("Search for a Wikidata entity");
  }
  getSuggestions(query) {
    return Entity.search(query);
  }
  async onChooseSuggestion(item, evt) {
    let loading = new import_obsidian2.Notice(`Importing entity ${item.id}...`);
    try {
      if (this.plugin.settings.internalLinkPrefix === "db/") {
        this.plugin.settings.internalLinkPrefix = "db/${label}";
      }
      let name = Entity.buildLink(
        this.plugin.settings.internalLinkPrefix + `.md`,
        item.label,
        item.id.substring(1)
      );
      console.log(name);
      let file = this.app.vault.getAbstractFileByPath(name);
      if (!(file instanceof import_obsidian2.TFile)) {
        file = await this.app.vault.create(name, "");
      }
      await syncEntityToFile(this.plugin, item, file);
      let leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf) {
        leaf.openFile(file);
      }
    } catch (e) {
      new import_obsidian2.Notice(`Error importing entity ${item.id}: ${e}`);
      return;
    } finally {
      loading.hide();
    }
  }
  renderSuggestion(entity, el) {
    el.createEl("div", { text: entity.label });
    el.createEl("small", { text: entity.description });
  }
};
var WikidataImporterPlugin = class extends import_obsidian2.Plugin {
  async importProperties() {
    var _a;
    let file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian2.Notice("No active file");
      return;
    }
    let frontmatter = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) || {};
    let entityId = frontmatter[this.settings.entityIdKey];
    if (!entityId || !entityId.startsWith("Q")) {
      new import_obsidian2.Notice(
        `No Wikidata entity ID found in frontmatter key "${this.settings.entityIdKey}", searching for a Wikidata entity from the file name "${file.basename}"...`
      );
      const modal = new WikidataEntitySuggestModal(this);
      modal.open();
      modal.inputEl.value = file.basename;
      modal.inputEl.dispatchEvent(new Event("input"));
      return;
    }
    let loading = new import_obsidian2.Notice("Loading properties from Wikidata...");
    let entity = Entity.fromId(entityId);
    try {
      await syncEntityToFile(this, entity, file);
    } catch (e) {
      new import_obsidian2.Notice(
        `Error importing properties for entity ${entity.id}: ${e}`
      );
      return;
    } finally {
      loading.hide();
    }
  }
  async importEntityFromHighlightedText() {
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian2.Notice("No active file");
      return;
    }
    let selection;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (view) {
      const view_mode = view.getMode();
      switch (view_mode) {
        case "preview":
          break;
        case "source":
          if ("editor" in view) {
            selection = view.editor.getSelection();
          }
          break;
        default:
          break;
      }
    }
    if (!selection) {
      new import_obsidian2.Notice("No text selected");
      return;
    }
    const loading = new import_obsidian2.Notice("Loading entity from highlighted text...");
    try {
      const modal = new WikidataEntitySuggestModal(this);
      modal.open();
      modal.inputEl.value = selection;
      modal.inputEl.dispatchEvent(new Event("input"));
    } catch (e) {
      new import_obsidian2.Notice(`Error importing entity from highlighted text: ${e}`);
      return;
    } finally {
      loading.hide();
    }
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "import-properties-for-active-file",
      name: "Import properties for active file",
      editorCallback: this.importProperties.bind(this)
    });
    this.addCommand({
      id: "import-entity",
      name: "Import entity",
      callback: () => {
        new WikidataEntitySuggestModal(this).open();
      }
    });
    this.addCommand({
      id: "import-entity-from-highlighted-text",
      name: "Import entity from highlighted text",
      editorCallback: this.importEntityFromHighlightedText.bind(this)
    });
    this.addSettingTab(new WikidataImporterSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WikidataImporterSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Wikidata entity ID key").setDesc("The frontmatter key to use for the Wikidata entity ID").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.entityIdKey).setValue(this.plugin.settings.entityIdKey).onChange(async (value) => {
        this.plugin.settings.entityIdKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Internal link prefix").setDesc(
      "The prefix to use for internal links to Wikidata entities"
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.internalLinkPrefix).setValue(this.plugin.settings.internalLinkPrefix).onChange(async (value) => {
        this.plugin.settings.internalLinkPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Ignore categories").setDesc(
      "If checked, categories will not be imported as properties"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ignoreCategories).onChange(async (value) => {
        this.plugin.settings.ignoreCategories = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName('Ignore "Wikipedia:" pages').setDesc(
      'If checked, pages starting with "Wikipedia:" (e.g. lists) will not be imported'
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ignoreWikipediaPages).onChange(async (value) => {
        this.plugin.settings.ignoreWikipediaPages = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Ignore ID properties").setDesc(
      "If checked, the plethora of ID properties will not be imported"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ignoreIDs).onChange(async (value) => {
        this.plugin.settings.ignoreIDs = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Ignore properties with time ranges").setDesc(
      "If checked, properties with time ranges will not be imported"
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.ignorePropertiesWithTimeRanges
      ).onChange(async (value) => {
        this.plugin.settings.ignorePropertiesWithTimeRanges = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Overwrite existing properties").setDesc(
      "If checked, existing properties will be overwritten when importing"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.overwriteExistingProperties).onChange(async (value) => {
        this.plugin.settings.overwriteExistingProperties = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Blocked properties").setDesc(
      "Do not import properties with these labels, one per line, even if they are allowed by the 'allowed properties' setting"
    ).addTextArea(
      (text) => {
        var _a;
        return text.setPlaceholder("label1\nlabel2\n...").setValue(
          (_a = this.plugin.settings.blockedProperties) == null ? void 0 : _a.join("\n")
        ).onChange(async (value) => {
          this.plugin.settings.blockedProperties = value.trim().split("\n").filter(Boolean);
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian2.Setting(containerEl).setName("Allowed properties").setDesc(
      "Only import properties with these labels, one per line, making the 'blocked properties' irrelevant"
    ).addTextArea(
      (text) => {
        var _a;
        return text.setPlaceholder("label1\nlabel2\n...").setValue(
          (_a = this.plugin.settings.allowedProperties) == null ? void 0 : _a.join("\n")
        ).onChange(async (value) => {
          this.plugin.settings.allowedProperties = value.trim().split("\n").filter(Boolean);
          await this.plugin.saveSettings();
        });
      }
    );
  }
};
